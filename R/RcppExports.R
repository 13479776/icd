# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

icd9IsASingleV <- function(s) {
    .Call('icd9_icd9IsASingleV', PACKAGE = 'icd9', s)
}

icd9IsASingleE <- function(s) {
    .Call('icd9_icd9IsASingleE', PACKAGE = 'icd9', s)
}

icd9IsASingleVE <- function(s) {
    .Call('icd9_icd9IsASingleVE', PACKAGE = 'icd9', s)
}

icd9IsV <- function(sv) {
    .Call('icd9_icd9IsV', PACKAGE = 'icd9', sv)
}

icd9IsE <- function(sv) {
    .Call('icd9_icd9IsE', PACKAGE = 'icd9', sv)
}

icd9IsVE <- function(sv) {
    .Call('icd9_icd9IsVE', PACKAGE = 'icd9', sv)
}

icd9IsN <- function(sv) {
    .Call('icd9_icd9IsN', PACKAGE = 'icd9', sv)
}

icd9IsV_cpp_slower <- function(sv) {
    .Call('icd9_icd9IsV_cpp_slower', PACKAGE = 'icd9', sv)
}

#' @name icd9ShortToParts_cpp_slow
#' @title extract major and minor parts of a decimal ICD-9 code
#' @description accepts Vxxxx Exxxx or xxxxx
#' @template icd9-short
#' @param minorEmpty vector of length one, to be used in place of
#' minor part of zero. Defaults to ""
#' @template invalid
#' @return data.frame with two columns. At least the minor part must be
#' character, because "03" is different to "3", but "30" is the same as "3"
#' @keywords manip
icd9ShortToParts_cpp_slow <- function(icd9Short, minorEmpty = "") {
    .Call('icd9_icd9ShortToParts_cpp_slow', PACKAGE = 'icd9', icd9Short, minorEmpty)
}

#' @name icd9MajMinToParts_slower
#' @title icd9MajMinToParts_slower
#' @description Convert vectors of major and minor components into a data frame with a column for major and a column for minor.
#' This is slightly slower than the R implementation. using Rcpp11 std::to_string is even slower than this.
#' @import Rcpp
#' @export
icd9MajMinToParts_slower <- function(mjr, mnr) {
    .Call('icd9_icd9MajMinToParts_slower', PACKAGE = 'icd9', mjr, mnr)
}

#' @name icd9Is_cpp_slow
#' @title is the given code V or E type?
#' @description quickly find V or E codes, without fully validating V or E
#'   codes. Use fixed instead of regex for speed. Don't check position of V or
#'   E: this is not validation, just a quick classification of pre-validated
#'   codes. TODO: this doesn't look efficient, but can't use fixed with ignore
#'   case, and regex slower.
#' @template icd9-any
#' @examples
#'
#' library(microbenchmark)
#' # regex is a little faster than fixed
#' icd9 <- rep(times = 500, c("1", "not", "V10.0", " E950", ""))
#' microbenchmark(times = 3,
#'   grepl(pattern = "E", icd9, fixed = TRUE) |
#'   grepl(pattern = "e", icd9, fixed = TRUE) |
#'   grepl(pattern = "V", icd9, fixed = TRUE) |
#'   grepl(pattern = "v", icd9, fixed = TRUE))
#' microbenchmark(times = 3, grepl(pattern = "[EeVv]", rnd))
#' microbenchmark(icd9:::icd9IsV_cpp_slower(icd9), icd9:::icd9IsV_R(icd9), icd9:::icd9IsV_cpp_slow(icd9), icd9:::icd9IsV(icd9))
#'
icd9IsV_cpp_slow <- function(sv) {
    .Call('icd9_icd9IsV_cpp_slow', PACKAGE = 'icd9', sv)
}

#' @rdname icd9Is_cpp_slow
icd9IsE_cpp_slow <- function(sv) {
    .Call('icd9_icd9IsE_cpp_slow', PACKAGE = 'icd9', sv)
}

#' @rdname icd9Is_cpp_slow
icd9IsVE_cpp_slow <- function(sv) {
    .Call('icd9_icd9IsVE_cpp_slow', PACKAGE = 'icd9', sv)
}

icd9ShortToParts_cpp_test <- function(icd9Short, minorEmpty = "") {
    .Call('icd9_icd9ShortToParts_cpp_test', PACKAGE = 'icd9', icd9Short, minorEmpty)
}

#' Trim whitespace from start and/or end of string
#'
#' @usage trim(input, side = "both")
#' @param input input character vector
#' @param side side on which whitespace is removed (left, right, or both)
#' @return character vector with leading and trailing whitespace removed
#' @examples
#' \dontrun{
#' trimString("\n\nString with trailing and leading white space \t")
#' }
stringTrim <- function(input, side = "both") {
    .Call('icd9_stringTrim', PACKAGE = 'icd9', input, side)
}

icd9MajMinToCode <- function(mjr, mnr, isShort) {
    .Call('icd9_icd9MajMinToCode', PACKAGE = 'icd9', mjr, mnr, isShort)
}

#' @name icd9MajMinToShort
#' @rdname icd9MajMinToShort
#' @title icd9MajMinToShort
#' @export
icd9MajMinToShort <- function(mjr, mnr) {
    .Call('icd9_icd9MajMinToShort', PACKAGE = 'icd9', mjr, mnr)
}

#' @name icd9MajMinToDecimal
#' @title icd9MajMinToDecimal
#' @export
icd9MajMinToDecimal <- function(mjr, mnr) {
    .Call('icd9_icd9MajMinToDecimal', PACKAGE = 'icd9', mjr, mnr)
}

#' @name icd9PartsToShort
#' @title icd9PartsToShort
#' @export
icd9PartsToShort <- function(parts) {
    .Call('icd9_icd9PartsToShort', PACKAGE = 'icd9', parts)
}

#' @name icd9PartsToDecimal
#' @title icd9PartsToDecimal
#' @export
icd9PartsToDecimal <- function(parts) {
    .Call('icd9_icd9PartsToDecimal', PACKAGE = 'icd9', parts)
}

#' @name icd9MajMinToParts
#' @title icd9MajMinToParts
#' @description Convert vectors of major and minor components into a data frame with a column for major and a column for minor.
#' This is 20x faster in this C++ implementation, and important for a very frequently used function.
#' @import Rcpp
#' @export
icd9MajMinToParts <- function(mjr, mnr) {
    .Call('icd9_icd9MajMinToParts', PACKAGE = 'icd9', mjr, mnr)
}

#' @name icd9MajMinToParts
#' @title icd9MajMinToParts
#' @description Convert vectors of major and minor components into a data frame with a column for major and a column for minor.
#' This is probably just as quick in R, but I think I may rely on having a data frame output (which is slower to construct in R)
#' @import Rcpp
#' @export
icd9MajMinToParts_list <- function(mjr, mnr) {
    .Call('icd9_icd9MajMinToParts_list', PACKAGE = 'icd9', mjr, mnr)
}

#' @name icd9ShortToParts
#' @title extract major and minor parts of a decimal ICD-9 code
#' @description accepts Vxxxx Exxxx or xxxxx. This version just beats native R, but lowerhead for calls. If minorEmpty is NA, it must be an NA_character_ (for now).
#' @template icd9-short
#' @param minorEmpty vector of length one, to be used in place of
#' minor part of zero. Defaults to ""
#' @template invalid
#' @return data.frame with two columns. At least the minor part must be
#' character, because "03" is different to "3", but "30" is the same as "3"
#' @keywords manip
#' @export
icd9ShortToParts <- function(icd9Short, minorEmpty = "") {
    .Call('icd9_icd9ShortToParts', PACKAGE = 'icd9', icd9Short, minorEmpty)
}

icd9DecimalToParts <- function(icd9Decimal, minorEmpty = "") {
    .Call('icd9_icd9DecimalToParts', PACKAGE = 'icd9', icd9Decimal, minorEmpty)
}

#' @name icd9ShortToDecimal
#' @title icd9ShortToDecimal
#' @export
icd9ShortToDecimal <- function(x) {
    .Call('icd9_icd9ShortToDecimal', PACKAGE = 'icd9', x)
}

#' @name icd9DecimalToShort
#' @title icd9ShortToDecimal
#' @export
icd9DecimalToShort <- function(x) {
    .Call('icd9_icd9DecimalToShort', PACKAGE = 'icd9', x)
}

#' @name icd9ExpandMinor
#' @title Expand a root 'minor' part of code into all possible children.
#' @examples
#'
#' microbenchmark(icd9:::icd9ExpandMinor("7", FALSE), icd9:::icd9ExpandMinor_R("7", FALSE))
#' microbenchmark(icd9:::icd9ExpandMinor("", FALSE), icd9:::icd9ExpandMinor_R("", FALSE))
#' microbenchmark(icd9:::icd9ExpandMinor("7", TRUE), icd9:::icd9ExpandMinor_R("7", TRUE))
#' microbenchmark(icd9:::icd9ExpandMinor("", TRUE), icd9:::icd9ExpandMinor_R("", TRUE))
#'
icd9ExpandMinor <- function(x, isE) {
    .Call('icd9_icd9ExpandMinor', PACKAGE = 'icd9', x, isE)
}

#' @title Expand 5 character form 'short' ICD9 to all possible sub codes
#' @description Much faster in C++, but gains diminished with increasing numbers of input shorts, probably because I am copying memory unnecessarily.
#' @rdname icd9ChildrenShort
#' @template icd9-short
#' @keywords manip
#' @family ICD-9 ranges
#' @examples
#'
#' library(microbenchmark)
#' "400" %i9s% "410" -> shorts
#' microbenchmark(icd9:::icd9ChildrenShort(shorts), icd9:::icd9ChildrenShort_R(shorts), times = 5)
#'
#' @export
icd9ChildrenShort <- function(icd9Short, onlyReal = FALSE) {
    .Call('icd9_icd9ChildrenShort', PACKAGE = 'icd9', icd9Short, onlyReal)
}

#' @title generate all child codes for given decimal ICD9 codes
#' @description take ICD9 codes in decimal form and lists of all possible
#'   sub-classification codes: e.g. 1.1 returns 1.11, 1.12, 1.13 etc. There are
#'   no codes like 1.10 which are distinct from 1.1, so this can be purely
#'   numeric Also, note that expanding "100.0" (100.00 to 100.09) is different
#'   from expanding "100.00" (no expansion) \code{0.1 == .3/3} is a problem...
#'   \url{http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-doesn_0027t-R-think-these-numbers-are-equal_003f}
#'
#' @template icd9-decimal
#' @template onlyReal
#' @examples
#' #icd9ChildrenDecimal("100.1")
#' #icd9ChildrenDecimal("2.34")
#' @return unsorted vector of ICD9 codes for all subsections of the provided
#'   code.
#' @family ICD-9 ranges
#' @keywords manip
#' @export
icd9ChildrenDecimal <- function(icd9Decimal, onlyReal = FALSE) {
    .Call('icd9_icd9ChildrenDecimal', PACKAGE = 'icd9', icd9Decimal, onlyReal)
}

#' @rdname icd9ChildrenShort
#' @template icd9-any
#' @template isShort
#' @template onlyReal
#' @family ICD-9 ranges
#' @keywords internal
icd9Children <- function(icd9, isShort, onlyReal = FALSE) {
    .Call('icd9_icd9Children', PACKAGE = 'icd9', icd9, isShort, onlyReal)
}

#' @title extract major part from short or decimal ICD-9 code
#' @description Simply extracts parts, then returns only the major part in a
#'   character vector
#' @template icd9-any
#' @template isShort
#' @template invalid
#' @return character vector
icd9GetMajor <- function(icd9, isShort) {
    .Call('icd9_icd9GetMajor', PACKAGE = 'icd9', icd9, isShort)
}

icd9AddLeadingZeroesMajorSingle <- function(ms) {
    .Call('icd9_icd9AddLeadingZeroesMajorSingle', PACKAGE = 'icd9', ms)
}

#' @rdname icd9AddLeadingZeroes
#' @description three digit codes are returned unchanged, one and two digit
#'   codes are preceded by 00 or 0.
icd9AddLeadingZeroesMajor <- function(mjr) {
    .Call('icd9_icd9AddLeadingZeroesMajor', PACKAGE = 'icd9', mjr)
}

#' @rdname icd9AddLeadingZeroes
#' @description Non-decimal ICD-9 codes with length<5 are often ambiguous. E.g.
#'   100 could be 1.00 10.0 or 100 if coded incorrectly. We must assume 100 is
#'   really 100
#' @template icd9-short
icd9AddLeadingZeroesShort <- function(icd9Short) {
    .Call('icd9_icd9AddLeadingZeroesShort', PACKAGE = 'icd9', icd9Short)
}

icd9AddLeadingZeroesDecimal <- function(icd9Decimal) {
    .Call('icd9_icd9AddLeadingZeroesDecimal', PACKAGE = 'icd9', icd9Decimal)
}

icd9AddLeadingZeroes <- function(icd9, isShort) {
    .Call('icd9_icd9AddLeadingZeroes', PACKAGE = 'icd9', icd9, isShort)
}

#' @title match ICD9 codes
#' @aliases "%i9in%"
#' @description Finds children of ricd9Reference and looks for icd9 in the
#'   resulting vector.  It is a glorified %in% function.
#' @templateVar icd9AnyName "icd9,icd9Reference"
#' @template icd9-any
#' @template isShort
#' @param isShortReference logical, see argument \code{isShort}
#' @template invalid
#' @return logical vector of which icd9 match or are subcategory of
#'   icd9Reference
#' @keywords internal
icd9InReferenceCode <- function(icd9, icd9Reference, isShort = TRUE, isShortReference = TRUE) {
    .Call('icd9_icd9InReferenceCode', PACKAGE = 'icd9', icd9, icd9Reference, isShort, isShortReference)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('icd9_RcppExport_registerCCallable', PACKAGE = 'icd9')
})
